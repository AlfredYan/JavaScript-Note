# JavaScript作用域及闭包

## 编译及变量查找方法

**分词/词法分析：** 将有意义的字符串分解成有意义的代码块（词法单元）。例如：var a = 2; 会被分解成：var、a、=、2、;。空格是否被当做词法单元，取决于空格在这门语言中是否有意义。

**解析/语法分析：** 将词法单元流转换成“抽象语法树”（AST）。

**代码生成：** 将AST转换为可 执行代码。

对于JavaScript来说，编译发生在代码执行前的几微秒。

**LHS：** 赋值操作的左侧。寻找变量的容器本身，从而可以对其**赋值**，不成功的LHS会自动隐式地创建一个全局变量。（var a = 2;）

**RHS：** 赋值操作的非左侧。查找某个变量的**值**。不成功的RHS会抛出ReferenceError。（console.log(a)）

*注：ReferenceError同作用域判别失败有关；TypeError表示作用判别成功，但对结果的操作是非法的。*

**变量的赋值操作：** 首先编译器会在当前作用域中声明一个变量（如果之前没有声明过），然后在运行时引擎会在作用域中进行LHS查找该变量，如果找到则对它赋值。

## 词法作用域

**作用域：** 作用域是一套规则，用于确定在何处以及如何查找变量。可分为**词法作用域**和**动态作用域** 。

**词法作用域：** 定义过程发生**在代码的书写阶段**。由写代码时将变量和块作用域写的位置决定。JavaScript采用的是词法作用域。

```javascript
function foo(){
  console.log(a);
}

function bar(){
  var a = 3;
  foo();
}

var a = 2;

bar(); // 2
```

**动态作用域：** 作用域在运行时决定，决定于何处调用，作用域链基于调用栈。

**JavaScript 作用域查找：** 作用域查找会在找到第一个匹配的标识符时停止。在多层嵌套的定义域中，如果有同名的标识符，则会发生“遮蔽效应”。查找始终从运行时所处的最内部作用开始，逐级向上进行，直到遇到第一个匹配的标识符。

*注：全局变量会自动成为全局对象的属性，因此可以通过对全局对象属性的引用来进行访问（window.a）。由此可以访问被同名变量所遮蔽的全局变量。* 

## 函数作用域 

**函数作用域：** 属于这个函数的全部变量都可以在整个函数的范围内使用及复用。

**函数表达式与函数声明：** 如果function是声明中的第一个词，那么就是一个函数声明，否则就是一个函数表达式。

**包装函数的申明：** 以(function...开始，函数会被当做一个函数表达式。可以不需要函数名并自动运行。将内部变量隐藏，不污染外部作用域。

```javascript
//立即执行函数表达式（IIFE）
var a = 2;

(function(global){
  var a = 3;
  console.log(a); // 3
  console.log(global.a); // 2
})(window);

console.log(a); // 2
```

**匿名与具名：** 函数表达式可以匿名，但声明不可以省略函数名。 

```javascript
// 匿名函数表达式
setTimeout( function() {
  console.log("I waited 1 second!")
}, 1000 )
```

**匿名函数的表达式的缺点：** 

1. 匿名函数在栈追踪中不会显示出有意义的函数名，调试困难。
2. 难以引用自身。
3. 由于没有函数名，降低了代码的可读性与可理解性。